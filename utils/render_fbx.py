import bpy
import os


def create_checkerboard_floor(checker_size=10):
    """
    Creates a checkerboard floor

    :param checker_size:
    :return: None
    """
    bpy.ops.mesh.primitive_plane_add(size=10, location=(0, 0, -1))
    floor = bpy.context.object
    floor.scale = (10, 10, 10)

    mat = bpy.data.materials.new(name="Checkerboard")       # Create checkerboard material
    mat.use_nodes = True
    nodes = mat.node_tree.nodes
    links = mat.node_tree.links

    for node in nodes:
        nodes.remove(node)

    texture = nodes.new(type='ShaderNodeTexChecker')
    texture.inputs['Scale'].default_value = checker_size
    diffuse = nodes.new(type='ShaderNodeBsdfDiffuse')
    output = nodes.new(type='ShaderNodeOutputMaterial')
    links.new(texture.outputs['Color'], diffuse.inputs['Color'])        # Link nodes
    links.new(diffuse.outputs['BSDF'], output.inputs['Surface'])

    if floor.data.materials:                                 # Assign material to floor
        floor.data.materials[0] = mat
    else:
        floor.data.materials.append(mat)


def render(fbx_file_path="../fbx_creator/output/", character_name="ulf.fbx", output_file_basename="ulf_animation", res_x=740, res_y=480, fps=24,
           cam_location=(-0.09, -75, 10.816), cam_rotation=(1.4728, 0, 0), checkerboard_floor=True, static_rendering=True, frame_length=50):
    """
    This function renders the animation from the FBX file

    :param fbx_file_path: the file that was generated by create_fbx.py
    :param output_file_basename: base name of the fbx_creator file
    :param res_x: resolution of the mp4 video in x direction
    :param res_y: resolution of the mp4 video in y direction
    :param fps: framerate
    :param cam_location: location of the virtual camera
    :param cam_rotation: rotation of the virtual camera
    :param checkerboard_floor: whether to create a checkerboard floor
    :param static_rendering: whether to render a static image or an animation
    :param frame_length: length of the animation
    :return: Nothing
    """

    # Filepaths
    dir_path = os.path.dirname(os.path.realpath(__file__))
    output_dir = os.path.join(dir_path, "../output/")
    fbx_file_path = os.path.join(dir_path, fbx_file_path + character_name)

    # General Setup and Render Settings
    bpy.ops.wm.read_factory_settings(use_empty=True)        # Clear existing objects
    bpy.ops.import_scene.fbx(filepath=fbx_file_path)        # Import FBX file
    bpy.context.scene.render.engine = 'BLENDER_EEVEE'              # 'CYCLES' or 'BLENDER_EEVEE'
    bpy.context.scene.render.resolution_x = res_x
    bpy.context.scene.render.resolution_y = res_y
    bpy.context.scene.render.fps = fps                      # Set to match FBX or desired fbx_creator
    if not static_rendering:
        output_format = ".mp4"  # Change to your preferred video format
        bpy.context.scene.render.image_settings.file_format = 'FFMPEG'
        bpy.context.scene.render.ffmpeg.format = 'MPEG4'
        bpy.context.scene.render.ffmpeg.codec = 'H264'
        bpy.context.scene.render.ffmpeg.constant_rate_factor = 'MEDIUM'
    else:
        output_format = ".png"
        bpy.context.scene.render.image_settings.file_format = 'PNG'
    bpy.context.scene.render.filepath = os.path.join(output_dir, output_file_basename + output_format)

    # Camera and Lighting
    bpy.ops.object.camera_add(location=cam_location)
    camera = bpy.context.object
    camera.rotation_euler = cam_rotation
    bpy.context.scene.camera = camera

    bpy.ops.object.light_add(type='POINT', location=(1, -77, 10))
    light = bpy.context.object
    light.data.energy = 2000000

    # Floor
    if checkerboard_floor:
        create_checkerboard_floor()

    # Render Animation
    if static_rendering:
        # Render just the first frame (idle state)
        bpy.context.scene.frame_start = 1
        bpy.context.scene.frame_end = 1
        bpy.ops.render.render(write_still=True)  # Render a still frame
    else:
        # Set animation length and render
        bpy.context.scene.frame_end = frame_length
        bpy.ops.render.render(animation=True, write_still=True)  # Render the animation
    print("Rendering completed and file saved to:", bpy.context.scene.render.filepath)


if __name__ == "__main__":
    render(checkerboard_floor=True, static_rendering=True)
